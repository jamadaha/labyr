pub mod path_set {
    use glob::glob;
    use path_absolutize::Absolutize;
    use serde::{de, Deserialize, Deserializer};
    use std::path::PathBuf;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<PathBuf>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: Vec<String> = Vec::deserialize(deserializer)?;
        let mut paths: Vec<PathBuf> = Vec::new();
        for s in s.into_iter() {
            let globbed = glob(&s).map_err(|e| {
                de::Error::custom(&format!("Failed to glob {} with error: {}", s, e))
            })?;
            for g in globbed.into_iter() {
                let path = g.map_err(|e| {
                    de::Error::custom(&format!("Globbing {} resulted in error: {}", s, e))
                })?;
                let path = path.absolutize().map_err(|e| {
                    de::Error::custom(&format!(
                        "Failed to absolutize path {:?} generated by globbing {} with error: {}",
                        path, s, e
                    ))
                })?;
                if !paths.contains(&path.to_path_buf()) {
                    paths.push(path.to_path_buf());
                }
            }
        }
        Ok(paths)
    }
}

pub mod path_set_named {
    use serde::{de, Deserializer};
    use std::{iter::zip, path::PathBuf};

    use super::path_set;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<(String, PathBuf)>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let paths = path_set::deserialize(deserializer)?;
        let mut names = vec![];
        for path in paths.iter() {
            let name = path.file_name().ok_or(de::Error::custom(format!(
                "Failed to get file name of {:?}",
                path
            )))?;
            names.push(name.to_string_lossy().to_string());
        }
        Ok(zip(names, paths).collect())
    }
}

pub mod abs_path {
    use std::path::PathBuf;

    use path_absolutize::Absolutize;
    use serde::{de, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PathBuf, D::Error>
    where
        D: Deserializer<'de>,
    {
        let path: PathBuf = PathBuf::deserialize(deserializer)?;
        let path = path.absolutize().map_err(|e| {
            de::Error::custom(&format!(
                "Failed to absolutize path {:?} with error: {}",
                path, e
            ))
        })?;
        Ok(path.to_path_buf())
    }
}

pub mod regex_pattern {
    use regex::Regex;
    use serde::{de, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Regex, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = String::deserialize(deserializer)?;
        let pattern: Regex = Regex::new(&s).map_err(|e| {
            de::Error::custom(&format!("Failed to parse regex {} with error: {}", &s, e))
        })?;
        Ok(pattern)
    }
}
