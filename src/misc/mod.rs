pub mod logging;
pub mod path_set {
    use glob::glob;
    use log::trace;
    use path_absolutize::Absolutize;
    use serde::{de, Deserialize, Deserializer};
    use std::{collections::HashSet, path::PathBuf};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<PathBuf>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: Vec<String> = Vec::deserialize(deserializer)?;
        let mut paths: HashSet<PathBuf> = HashSet::new();
        for s in s.into_iter() {
            let globbed = glob(&s).map_err(|e| {
                de::Error::custom(&format!("Failed to glob {} with error: {}", s, e))
            })?;
            for g in globbed.into_iter() {
                let path = g.map_err(|e| {
                    de::Error::custom(&format!("Globbing {} resulted in error: {}", s, e))
                })?;
                trace!("Absoluzing path {:?}", path);
                let path = path.absolutize().map_err(|e| {
                    de::Error::custom(&format!(
                        "Failed to absolutize path {:?} generated by globbing {} with error: {}",
                        path, s, e
                    ))
                })?;
                paths.insert(path.to_path_buf());
            }
        }
        Ok(paths.into_iter().collect())
    }
}

pub mod abs_path {
    use std::path::PathBuf;

    use log::trace;
    use path_absolutize::Absolutize;
    use serde::{de, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PathBuf, D::Error>
    where
        D: Deserializer<'de>,
    {
        let path: PathBuf = PathBuf::deserialize(deserializer)?;
        trace!("Absoluzing path {:?}", path);
        let path = path.absolutize().map_err(|e| {
            de::Error::custom(&format!(
                "Failed to absolutize path {:?} with error: {}",
                path, e
            ))
        })?;
        Ok(path.to_path_buf())
    }
}

pub mod regex_pattern {
    use log::trace;
    use regex::Regex;
    use serde::{de, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Regex, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = String::deserialize(deserializer)?;
        trace!("Parsing regex: {}", &s);
        let pattern: Regex = Regex::new(&s).map_err(|e| {
            de::Error::custom(&format!("Failed to parse regex {} with error: {}", &s, e))
        })?;
        Ok(pattern)
    }
}
