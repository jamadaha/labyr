pub mod logging;
pub mod path_set {
    use glob::glob;
    use log::trace;
    use path_absolutize::Absolutize;
    use serde::{de, Deserialize, Deserializer};
    use std::path::PathBuf;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<PathBuf>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = String::deserialize(deserializer)?;
        trace!("Globbing {}", &s);
        let globbed = glob(&s)
            .map_err(|e| de::Error::custom(&format!("Failed to glob {} with error: {}", s, e)))?;
        let mut paths = vec![];
        for g in globbed.into_iter() {
            let path = g.map_err(|e| {
                de::Error::custom(&format!("Globbing {} resulted in error: {}", s, e))
            })?;
            trace!("Absoluzing path {:?}", path);
            let path = path.absolutize().map_err(|e| {
                de::Error::custom(&format!(
                    "Failed to absolutize path {:?} generated by globbing {} with error: {}",
                    path, s, e
                ))
            })?;
            paths.push(path.to_path_buf());
        }
        Ok(paths)
    }
}

pub mod abs_path {
    use std::path::PathBuf;

    use log::trace;
    use path_absolutize::Absolutize;
    use serde::{de, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<PathBuf, D::Error>
    where
        D: Deserializer<'de>,
    {
        let path: PathBuf = PathBuf::deserialize(deserializer)?;
        trace!("Absoluzing path {:?}", path);
        let path = path.absolutize().map_err(|e| {
            de::Error::custom(&format!(
                "Failed to absolutize path {:?} with error: {}",
                path, e
            ))
        })?;
        Ok(path.to_path_buf())
    }
}

pub mod regex_pattern {
    use log::trace;
    use regex::Regex;
    use serde::{de, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Regex, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = String::deserialize(deserializer)?;
        trace!("Parsing regex: {}", &s);
        let pattern: Regex = Regex::new(&s).map_err(|e| {
            de::Error::custom(&format!("Failed to parse regex {} with error: {}", &s, e))
        })?;
        Ok(pattern)
    }
}
